// generated by ts2fable and transformer
namespace FsHafas.Client

open System

#if FABLE_COMPILER
open Fable.Core
open Fable.Core.JS
#endif

/// <namespacedoc>
///   <summary>FsHafas client types generated from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/hafas-client/index.d.ts">TS types</a></summary>
/// </namespacedoc>
/// A ProductType relates to how a means of transport "works" in local context.
/// Example: Even though S-Bahn and U-Bahn in Berlin are both trains, they have different operators, service patterns,
/// stations and look different. Therefore, they are two distinct products subway and suburban.
type ProductType =
    { id: string
      mode: ProductTypeMode
      name: string
      short: string
      bitmasks: array<int>
      ``default``: bool }

/// A profile is a specific customisation for each endpoint.
/// It parses data from the API differently, add additional information, or enable non-default methods.
and Profile =
    abstract member locale: string
    abstract member timezone: string
    abstract member endpoint: string
    abstract member products: array<ProductType>
    abstract member trip: bool option
    abstract member radar: bool option
    abstract member refreshJourney: bool option
    abstract member journeysFromTrip: bool option
    abstract member reachableFrom: bool option
    abstract member journeysWalkingSpeed: bool option
    abstract member tripsByName: bool option
    abstract member remarks: bool option
    abstract member remarksGetPolyline: bool option
    abstract member lines: bool option

/// A location object is used by other items to indicate their locations.
and Location =
    { ``type``: LocationType
      id: string option
      name: string option
      poi: bool option
      address: string option
      longitude: float option
      latitude: float option
      altitude: float option
      distance: int option }

/// Each public transportation network exposes its products as boolean properties. See {@link ProductType}
and Products = IndexMap<string, bool>
and Facilities = IndexMap<string, string>

and ReisezentrumOpeningHours =
    { Mo: string option
      Di: string option
      Mi: string option
      Do: string option
      Fr: string option
      Sa: string option
      So: string option }

/// A station is a larger building or area that can be identified by a name.
/// It is usually represented by a single node on a public transport map.
/// Whereas a stop usually specifies a location, a station often is a broader area
/// that may span across multiple levels or buildings.
and Station =
    {
        ``type``: StationType
        id: string option
        name: string option
        station: Station option
        location: Location option
        products: Products option
        lines: array<Line> option
        isMeta: bool option
        /// region ids
        regions: array<string> option
        facilities: Facilities option
        reisezentrumOpeningHours: ReisezentrumOpeningHours option
        stops: array<StationStopLocation> option
        entrances: array<Location> option
        transitAuthority: string option
        distance: int option
    }

/// Ids of a Stop, i.e. dhid as 'DELFI Haltestellen ID'
and Ids = IndexMap<string, string>

/// A stop is a single small point or structure at which vehicles stop.
/// A stop always belongs to a station. It may for example be a sign, a basic shelter or a railway platform.
and Stop =
    { ``type``: StopType
      id: string option
      name: string option
      location: Location option
      station: Station option
      products: Products option
      lines: array<Line> option
      isMeta: bool option
      facilities: Facilities option
      reisezentrumOpeningHours: ReisezentrumOpeningHours option
      ids: Ids option
      loadFactor: string option
      entrances: array<Location> option
      transitAuthority: string option
      distance: int option }

/// A region is a group of stations, for example a metropolitan area or a geographical or cultural region.
and Region =
    {
        ``type``: RegionType
        id: string
        name: string
        /// station ids
        stations: array<string>
    }

and Line =
    {
        ``type``: LineType
        matchId: string option
        id: string option
        name: string option
        adminCode: string option
        fahrtNr: string option
        additionalName: string option
        product: string option
        ``public``: bool option
        mode: ProductTypeMode option
        /// routes ids
        routes: array<string> option
        operator: Operator option
        express: bool option
        metro: bool option
        night: bool option
        nr: int option
        symbol: string option
        directions: array<string> option
        productName: string option
    }

/// A route represents a single set of stations, of a single line.
and Route =
    {
        ``type``: RouteType
        id: string
        line: string
        mode: ProductTypeMode
        /// stop ids
        stops: array<string>
    }

and Cycle =
    { min: int option
      max: int option
      nr: int option }

and ArrivalDeparture =
    { arrival: float option
      departure: float option }

/// There are many ways to format schedules of public transport routes.
/// This one tries to balance the amount of data and consumability.
/// It is specifically geared towards urban public transport, with frequent trains and homogenous travels.
and Schedule =
    {
        ``type``: ScheduleType
        id: string
        route: string
        mode: ProductTypeMode
        sequence: array<ArrivalDeparture>
        /// array of Unix timestamps
        starts: array<string>
    }

and Operator =
    { ``type``: OperatorType
      id: string
      name: string }

and Hint =
    { ``type``: HintType
      code: string option
      summary: string option
      text: string
      tripId: string option }

and Status =
    { ``type``: HintType
      code: string option
      summary: string option
      text: string
      tripId: string option }

and IcoCrd =
    { x: int
      y: int
      ``type``: string option }

and Edge =
    { fromLocation: StationStopLocation option
      toLocation: StationStopLocation option
      icon: Icon option
      dir: int option
      icoCrd: IcoCrd option }

and Event =
    { fromLocation: StationStopLocation option
      toLocation: StationStopLocation option
      start: string option
      ``end``: string option
      sections: array<string> option }

and Warning =
    { ``type``: WarningType
      id: string option
      icon: Icon option
      summary: string option
      text: string option
      category: string option
      priority: int option
      products: Products option
      edges: array<Edge> option
      events: array<Event> option
      validFrom: string option
      validUntil: string option
      modified: string option
      company: string option
      categories: array<int> option
      affectedLines: array<Line> option
      fromStops: array<StationStopLocation> option
      toStops: array<StationStopLocation> option }

and Geometry =
    { ``type``: GeometryType
      coordinates: array<float> }

and Feature =
    { ``type``: FeatureType
      properties: StationStopLocation option
      geometry: Geometry }

and FeatureCollection =
    { ``type``: FeatureCollectionType
      features: array<Feature> }

and [<StringEnum>] PrognosisType =
    | [<CompiledName "prognosed">] Prognosed
    | [<CompiledName "calculated">] Calculated

/// A stopover represents a vehicle stopping at a stop/station at a specific time.
and StopOver =
    {
        stop: StationStop option
        /// null, if last stopOver of trip
        departure: string option
        departureDelay: int option
        prognosedDeparture: string option
        plannedDeparture: string option
        departurePlatform: string option
        prognosedDeparturePlatform: string option
        plannedDeparturePlatform: string option
        /// null, if first stopOver of trip
        arrival: string option
        arrivalDelay: int option
        prognosedArrival: string option
        plannedArrival: string option
        arrivalPlatform: string option
        prognosedArrivalPlatform: string option
        plannedArrivalPlatform: string option
        remarks: array<HintStatusWarning> option
        passBy: bool option
        cancelled: bool option
        departurePrognosisType: PrognosisType option
        arrivalPrognosisType: PrognosisType option
        additional: bool option
    }

/// Trip â€“ a vehicle stopping at a set of stops at specific times
and Trip =
    { id: string
      origin: StationStopLocation option
      destination: StationStopLocation option
      departure: string option
      plannedDeparture: string option
      prognosedArrival: string option
      departureDelay: int option
      departurePlatform: string option
      prognosedDeparturePlatform: string option
      plannedDeparturePlatform: string option
      arrival: string option
      plannedArrival: string option
      prognosedDeparture: string option
      arrivalDelay: int option
      arrivalPlatform: string option
      prognosedArrivalPlatform: string option
      plannedArrivalPlatform: string option
      stopovers: array<StopOver> option
      schedule: float option
      price: Price option
      operator: float option
      direction: string option
      line: Line option
      cancelled: bool option
      walking: bool option
      loadFactor: string option
      distance: int option
      ``public``: bool option
      transfer: bool option
      cycle: Cycle option
      alternatives: array<Alternative> option
      polyline: FeatureCollection option
      remarks: array<HintStatusWarning> option
      currentLocation: Location option
      departurePrognosisType: PrognosisType option
      arrivalPrognosisType: PrognosisType option
      checkin: bool option
      scheduledDays: ScheduledDays option }

and TripWithRealtimeData =
    { realtimeDataUpdatedAt: int option
      trip: Trip }

and TripsWithRealtimeData =
    { realtimeDataUpdatedAt: int option
      trips: array<Trip> }

and WarningsWithRealtimeData =
    { realtimeDataUpdatedAt: int option
      remarks: array<Warning> }

and LinesWithRealtimeData =
    { realtimeDataUpdatedAt: int option
      lines: array<Line> option }

and Price =
    { amount: float
      currency: string option
      hint: string option }

and PriceObj =
    {
        /// amount in cents of currency
        amount: float
    }

and Ticket =
    {
        name: string
        priceObj: PriceObj option
        /// *bahn.de* URL to the tickets, see {@link JourneysOptionsDbProfile.generateUnreliableTicketUrls}
        url: string option
    }

and Alternative =
    { tripId: string
      direction: string option
      location: Location option
      line: Line option
      stop: StationStop option
      ``when``: string option
      plannedWhen: string option
      prognosedWhen: string option
      delay: int option
      platform: string option
      plannedPlatform: string option
      prognosedPlatform: string option
      remarks: array<HintStatusWarning> option
      cancelled: bool option
      loadFactor: string option
      provenance: string option
      previousStopovers: array<StopOver> option
      nextStopovers: array<StopOver> option
      frames: array<Frame> option
      polyline: FeatureCollection option
      currentTripPosition: Location option
      origin: StationStopLocation option
      destination: StationStopLocation option
      prognosisType: PrognosisType option }

and Departures =
    { realtimeDataUpdatedAt: int option
      departures: array<Alternative> }

and Arrivals =
    { realtimeDataUpdatedAt: int option
      arrivals: array<Alternative> }

/// Leg of journey
and Leg =
    { tripId: string option
      origin: StationStopLocation option
      destination: StationStopLocation option
      departure: string option
      plannedDeparture: string option
      prognosedArrival: string option
      departureDelay: int option
      departurePlatform: string option
      prognosedDeparturePlatform: string option
      plannedDeparturePlatform: string option
      arrival: string option
      plannedArrival: string option
      prognosedDeparture: string option
      arrivalDelay: int option
      arrivalPlatform: string option
      prognosedArrivalPlatform: string option
      plannedArrivalPlatform: string option
      stopovers: array<StopOver> option
      schedule: float option
      price: Price option
      operator: float option
      direction: string option
      line: Line option
      reachable: bool option
      cancelled: bool option
      walking: bool option
      loadFactor: string option
      distance: int option
      ``public``: bool option
      transfer: bool option
      cycle: Cycle option
      alternatives: array<Alternative> option
      polyline: FeatureCollection option
      remarks: array<HintStatusWarning> option
      currentLocation: Location option
      departurePrognosisType: PrognosisType option
      arrivalPrognosisType: PrognosisType option
      checkin: bool option }

and ScheduledDays = IndexMap<string, bool>

/// A journey is a computed set of directions to get from A to B at a specific time.
/// It would typically be the result of a route planning algorithm.
and Journey =
    { ``type``: JourneyType
      legs: array<Leg>
      refreshToken: string option
      remarks: array<HintStatusWarning> option
      price: Price option
      tickets: array<Ticket> option
      cycle: Cycle option
      scheduledDays: ScheduledDays option }

and Journeys =
    { realtimeDataUpdatedAt: int option
      earlierRef: string option
      laterRef: string option
      journeys: array<Journey> option }

and JourneyWithRealtimeData =
    { realtimeDataUpdatedAt: int option
      journey: Journey }

and Duration =
    { duration: int
      stations: array<StationStopLocation> }

and DurationsWithRealtimeData =
    { realtimeDataUpdatedAt: int option
      reachable: array<Duration> }

and Frame =
    { origin: StopLocation
      destination: StopLocation
      t: int option }

and Movement =
    { direction: string option
      tripId: string option
      line: Line option
      location: Location option
      nextStopovers: array<StopOver> option
      frames: array<Frame> option
      polyline: FeatureCollection option }

and Radar =
    { realtimeDataUpdatedAt: int option
      movements: array<Movement> option }

and ServerInfo =
    { realtimeDataUpdatedAt: int option
      hciVersion: string option
      timetableStart: string option
      timetableEnd: string option
      serverTime: string option }

and JourneysOptionsCommon =
    {
        /// departure date, undefined corresponds to Date.Now
        departure: DateTime option
        /// arrival date, departure and arrival are mutually exclusive.
        arrival: DateTime option
        /// earlierThan, use {@link Journeys#earlierRef}, earlierThan and departure/arrival are mutually exclusive.
        earlierThan: string option
        /// laterThan, use {@link Journeys#laterRef}, laterThan and departure/arrival are mutually exclusive.
        laterThan: string option
        /// how many search results?
        results: int option
        /// let journeys pass this station
        via: string option
        /// return stations on the way?
        stopovers: bool option
        /// Maximum nr of transfers. Default: Let HAFAS decide.
        transfers: int option
        /// minimum time for a single transfer in minutes
        transferTime: int option
        /// 'none', 'partial' or 'complete'
        accessibility: string option
        /// only bike-friendly journeys
        bike: bool option
        products: Products option
        /// return tickets? only available with some profiles
        tickets: bool option
        /// return a shape for each leg?
        polylines: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// 'slow', 'normal', 'fast'
        walkingSpeed: string option
        /// start with walking
        startWithWalking: bool option
        /// language to get results in
        language: string option
        /// parse which days each journey is valid on
        scheduledDays: bool option
        ``when``: DateTime option
    }

and LoyaltyCard =
    { ``type``: string
      discount: int option
      ``class``: int option }

and [<StringEnum>] AgeGroup =
    | [<CompiledName "B">] B
    | [<CompiledName "K">] K
    | [<CompiledName "Y">] Y
    | [<CompiledName "E">] E
    | [<CompiledName "S">] S

and [<StringEnum>] RoutingMode =
    | [<CompiledName "OFF">] OFF
    | [<CompiledName "INFOS">] INFOS
    | [<CompiledName "FULL">] FULL
    | [<CompiledName "REALTIME">] REALTIME
    | [<CompiledName "SERVER_DEFAULT">] SERVER_DEFAULT
    | [<CompiledName "HYBRID">] HYBRID

/// JourneysOptions specific to Db Profile
and JourneysOptionsDbProfile =
    {
        /// firstClass
        firstClass: bool option
        /// ageGroup
        ageGroup: AgeGroup option
        /// age
        age: int option
        /// LoyaltyCard
        loyaltyCard: LoyaltyCard option
        /// RoutingMode
        routingMode: RoutingMode option
        /// try to generate *bahn.de* URLs to the tickets
        generateUnreliableTicketUrls: bool option
    }

and JourneysOptions =
    {
        /// departure date, undefined corresponds to Date.Now
        departure: DateTime option
        /// arrival date, departure and arrival are mutually exclusive.
        arrival: DateTime option
        /// earlierThan, use {@link Journeys#earlierRef}, earlierThan and departure/arrival are mutually exclusive.
        earlierThan: string option
        /// laterThan, use {@link Journeys#laterRef}, laterThan and departure/arrival are mutually exclusive.
        laterThan: string option
        /// how many search results?
        results: int option
        /// let journeys pass this station
        via: string option
        /// return stations on the way?
        stopovers: bool option
        /// Maximum nr of transfers. Default: Let HAFAS decide.
        transfers: int option
        /// minimum time for a single transfer in minutes
        transferTime: int option
        /// 'none', 'partial' or 'complete'
        accessibility: string option
        /// only bike-friendly journeys
        bike: bool option
        products: Products option
        /// return tickets? only available with some profiles
        tickets: bool option
        /// return a shape for each leg?
        polylines: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// 'slow', 'normal', 'fast'
        walkingSpeed: string option
        /// start with walking
        startWithWalking: bool option
        /// language to get results in
        language: string option
        /// parse which days each journey is valid on
        scheduledDays: bool option
        ``when``: DateTime option
        /// firstClass
        firstClass: bool option
        /// ageGroup
        ageGroup: AgeGroup option
        /// age
        age: int option
        /// LoyaltyCard
        loyaltyCard: LoyaltyCard option
        /// RoutingMode
        routingMode: RoutingMode option
        /// try to generate *bahn.de* URLs to the tickets
        generateUnreliableTicketUrls: bool option
    }

and JourneysFromTripOptions =
    {
        /// return stations on the way?
        stopovers: bool option
        /// minimum time for a single transfer in minutes
        transferTime: int option
        /// 'none', 'partial' or 'complete'
        accessibility: string option
        /// return tickets?
        tickets: bool option
        /// return leg shapes?
        polylines: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// products
        products: Products option
    }

and LocationsOptions =
    {
        /// find only exact matches?
        fuzzy: bool option
        /// how many search results?
        results: int option
        /// return stops/stations?
        stops: bool option
        /// return addresses
        addresses: bool option
        /// points of interest
        poi: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose lines at each stop/station?
        linesOfStops: bool option
        /// Language of the results
        language: string option
    }

and TripOptions =
    {
        /// return stations on the way?
        stopovers: bool option
        /// return a shape for the trip?
        polyline: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// parse which days each journey is valid on
        scheduledDays: bool option
        /// Language of the results
        language: string option
    }

and StopOptions =
    {
        /// parse & expose lines at the stop/station?
        linesOfStops: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// Language of the results
        language: string option
    }

and DeparturesArrivalsOptions =
    {
        /// departure date, undefined corresponds to Date.Now
        ``when``: DateTime option
        /// only show departures heading to this station
        direction: string option
        /// filter by line ID
        line: string option
        /// show departures for the next n minutes
        duration: int option
        /// max. number of results; `null` means "whatever HAFAS wants"
        results: int option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose lines at the stop/station?
        linesOfStops: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// fetch & parse previous/next stopovers?
        stopovers: bool option
        /// departures at related stations
        includeRelatedStations: bool option
        /// products
        products: Products option
        /// language
        language: string option
    }

and RefreshJourneyOptions =
    {
        /// return stations on the way?
        stopovers: bool option
        /// return a shape for each leg?
        polylines: bool option
        /// return tickets? only available with some profiles
        tickets: bool option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose hints & warnings?
        remarks: bool option
        /// parse & expose dates the journey is valid on?
        scheduledDays: bool option
        /// try to generate *bahn.de* URLs to the tickets
        generateUnreliableTicketUrls: bool option
        /// language
        language: string option
    }

and NearByOptions =
    {
        /// maximum number of results
        results: int option
        /// maximum walking distance in meters
        distance: int option
        /// return points of interest?
        poi: bool option
        /// return stops/stations?
        stops: bool option
        /// products
        products: Products option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// parse & expose lines at each stop/station?
        linesOfStops: bool option
        /// language
        language: string option
    }

and ReachableFromOptions =
    {
        /// when
        ``when``: DateTime option
        /// maximum of transfers
        maxTransfers: int option
        /// maximum travel duration in minutes, pass `null` for infinite
        maxDuration: int option
        /// products
        products: Products option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// return leg shapes?
        polylines: bool option
    }

and BoundingBox =
    { north: float
      west: float
      south: float
      east: float }

and RadarOptions =
    {
        /// maximum number of vehicles
        results: int option
        /// nr of frames to compute
        frames: int option
        /// optionally an object of booleans
        products: Products option
        /// compute frames for the next n seconds
        duration: int option
        /// parse & expose sub-stops of stations?
        subStops: bool option
        /// parse & expose entrances of stops/stations?
        entrances: bool option
        /// return a shape for the trip?
        polylines: bool option
        /// when
        ``when``: DateTime option
    }

and Filter =
    { ``type``: string
      mode: string
      value: string }

and TripsByNameOptions =
    {
        /// departure date, undefined corresponds to Date.Now
        ``when``: DateTime option
        fromWhen: DateTime option
        untilWhen: DateTime option
        onlyCurrentlyRunning: bool option
        products: Products option
        currentlyStoppingAt: string option
        lineName: string option
        operatorNames: array<string> option
        additionalFilters: array<Filter> option
    }

and RemarksOptions =
    {
        from: DateTime option
        ``to``: DateTime option
        /// maximum number of remarks
        results: int option
        products: Products option
        /// return leg shapes? (not supported by all endpoints)
        polylines: bool option
        /// Language of the results
        language: string option
    }

and LinesOptions =
    {
        /// Language of the results
        language: string option
    }

and ServerOptions =
    {
        /// versionInfo
        versionInfo: bool option
        /// Language of the results
        language: string option
    }

and HafasClient =
    /// Retrieves journeys
    abstract member journeys:
        U4<string, Station, Stop, Location> ->
        U4<string, Station, Stop, Location> ->
        JourneysOptions option ->
            Promise<Journeys>

    /// refreshes a Journey
    abstract member refreshJourney: string -> RefreshJourneyOptions option -> Promise<JourneyWithRealtimeData>
    /// Refetch information about a trip
    abstract member trip: string -> TripOptions option -> Promise<TripWithRealtimeData>

    /// Retrieves departures
    abstract member departures:
        U4<string, Station, Stop, Location> -> DeparturesArrivalsOptions option -> Promise<Departures>

    /// Retrieves arrivals
    abstract member arrivals:
        U4<string, Station, Stop, Location> -> DeparturesArrivalsOptions option -> Promise<Arrivals>

    /// Retrieves journeys from trip id to station
    abstract member journeysFromTrip:
        string -> StopOver -> U4<string, Station, Stop, Location> -> JourneysFromTripOptions option -> Promise<Journeys>

    /// Retrieves locations or stops
    abstract member locations: string -> LocationsOptions option -> Promise<array<StationStopLocation>>
    /// Retrieves information about a stop
    abstract member stop: U2<string, Stop> -> StopOptions option -> Promise<StationStopLocation>
    /// Retrieves nearby stops from location
    abstract member nearby: Location -> NearByOptions option -> Promise<array<StationStopLocation>>
    /// Retrieves stations reachable within a certain time from a location
    abstract member reachableFrom: Location -> ReachableFromOptions option -> Promise<DurationsWithRealtimeData>
    /// Retrieves all vehicles currently in an area.
    abstract member radar: BoundingBox -> RadarOptions option -> Promise<Radar>
    /// Retrieves trips by name.
    abstract member tripsByName: string -> TripsByNameOptions option -> Promise<TripsWithRealtimeData>
    /// Fetches all remarks known to the HAFAS endpoint
    abstract member remarks: RemarksOptions option -> Promise<WarningsWithRealtimeData>
    /// Fetches all lines known to the HAFAS endpoint
    abstract member lines: string -> LinesOptions option -> Promise<LinesWithRealtimeData>
    /// Fetches meta information from the HAFAS endpoint
    abstract member serverInfo: ServerOptions option -> Promise<ServerInfo>

and [<StringEnum>] ProductTypeMode =
    | [<CompiledName "train">] Train
    | [<CompiledName "bus">] Bus
    | [<CompiledName "watercraft">] Watercraft
    | [<CompiledName "taxi">] Taxi
    | [<CompiledName "gondola">] Gondola
    | [<CompiledName "aircraft">] Aircraft
    | [<CompiledName "car">] Car
    | [<CompiledName "bicycle">] Bicycle
    | [<CompiledName "walking">] Walking

and [<StringEnum>] HintType =
    | [<CompiledName "hint">] Hint
    | [<CompiledName "status">] Status
    | [<CompiledName "foreign-id">] ForeignId
    | [<CompiledName "local-fare-zone">] LocalFareZone
    | [<CompiledName "stop-website">] StopWebsite
    | [<CompiledName "stop-dhid">] StopDhid
    | [<CompiledName "transit-authority">] TransitAuthority

and [<StringEnum>] WarningType =
    | [<CompiledName "status">] Status
    | [<CompiledName "warning">] Warning

and [<StringEnum>] LocationType = | [<CompiledName "location">] Location

and [<StringEnum>] StationType = | [<CompiledName "station">] Station

and [<StringEnum>] StopType = | [<CompiledName "stop">] Stop

and [<StringEnum>] LineType = | [<CompiledName "line">] Line

and [<StringEnum>] JourneyType = | [<CompiledName "journey">] Journey

and [<StringEnum>] RouteType = | [<CompiledName "route">] Route

and [<StringEnum>] RegionType = | [<CompiledName "region">] Region

and [<StringEnum>] ScheduleType = | [<CompiledName "schedule">] Schedule

and [<StringEnum>] OperatorType = | [<CompiledName "operator">] Operator

and [<StringEnum>] GeometryType = | [<CompiledName "Point">] Point

and [<StringEnum>] FeatureType = | [<CompiledName "Feature">] Feature

and [<StringEnum>] FeatureCollectionType = | [<CompiledName "featureCollection">] FeatureCollection

#if FABLE_JS
and [<Erase>] StationStopLocation =
    | Station of Station
    | Stop of Stop
    | Location of Location

and [<Erase>] StationStop =
    | Station of Station
    | Stop of Stop

and [<Erase>] StopLocation =
    | Stop of Stop
    | Location of Location

and [<Erase>] HintStatusWarning =
    | Hint of Hint
    | Status of Status
    | Warning of Warning
#else
and StationStopLocation =
    | Station of Station
    | Stop of Stop
    | Location of Location

and StationStop =
    | Station of Station
    | Stop of Stop

and StopLocation =
    | Stop of Stop
    | Location of Location

and HintStatusWarning =
    | Hint of Hint
    | Status of Status
    | Warning of Warning
#endif
