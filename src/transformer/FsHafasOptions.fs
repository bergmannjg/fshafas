module FsHafasOptions

//
// Hafas domain specfic transformations
//

let prelude = """/// generated by ts2fable and transformer
namespace FsHafas.Client
/// <namespacedoc>
///   <summary>FsHafas client types generated from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/hafas-client/index.d.ts">TS types</a></summary>
/// </namespacedoc>

#if FABLE_COMPILER
#nowarn "0059"
#endif

open System

#if FABLE_COMPILER
open Fable.Core
open Fable.Core.JS
#endif

#if !FABLE_COMPILER
type Promise<'T> = Async<'T>

[<AttributeUsage(AttributeTargets.Class)>]
type StringEnumAttribute() =
    inherit Attribute()
#endif

type Log() =
    static let mutable debug = false

    static member Debug
        with get () = debug
        and set (v) = debug <- v

    static member Print (msg: string) (o: obj) = if debug then printfn "%s %A" msg o

#if FABLE_COMPILER
type IndexMap<'s, 'b when 's: comparison>(defaultValue: 'b) =
    [<EmitIndexer>]
    member __.Item
        with get (s: 's): 'b = jsNative
        and set s b = jsNative

    [<Emit("(Object.keys($0))")>]
    member __.Keys : 's [] = jsNative
#else
type IndexMap<'s, 'b when 's: comparison>(defaultValue: 'b) =
    let mutable map: Map<'s, 'b> = Map.empty

    member __.Item
        with get (s: 's) =
            match map.TryFind s with
            | Some v -> v
            | None -> defaultValue
        and set s b =
            map <- map.Add(s, b)
            ()

    member __.Keys =
        map |> Seq.map (fun kv -> kv.Key) |> Seq.toArray
#endif
"""

/// todo: add attributes to transformer
let postlude = """
    and [<StringEnum; RequireQualifiedAccess>] ProductTypeMode =
        | [<CompiledName "train">] Train
        | [<CompiledName "bus">] Bus
        | [<CompiledName "watercraft">] Watercraft
        | [<CompiledName "taxi">] Taxi
        | [<CompiledName "gondola">] Gondola
        | [<CompiledName "aircraft">] Aircraft
        | [<CompiledName "car">] Car
        | [<CompiledName "bicycle">] Bicycle
        | [<CompiledName "walking">] Walking

    and [<StringEnum; RequireQualifiedAccess>] HintType =
        | [<CompiledName "hint">] Hint
        | [<CompiledName "status">] Status
        | [<CompiledName "foreign-id">] ForeignId
        | [<CompiledName "local-fare-zone">] LocalFareZone
        | [<CompiledName "stop-website">] StopWebsite
        | [<CompiledName "stop-dhid">] StopDhid
        | [<CompiledName "transit-authority">] TransitAuthority

    and [<StringEnum; RequireQualifiedAccess>] WarningType =
        | [<CompiledName "status">] Status
        | [<CompiledName "warning">] Warning
"""

let transformType str =
    if str = "ReadonlyArray" then "array"
    else if str = "ResizeArray" then "array"
    else str

let escapeIdent str =
    if str = "type" then
        "``" + str + "``"
    else if str = "default" then
        "``" + str + "``"
    else if str = "when" then
        "``" + str + "``"
    else if str = "end" then
        "``" + str + "``"
    else if str = "public" then
        "``" + str + "``"
    else if str = "to" then
        "``" + str + "``"
    else
        str

let excludeTypes = [| "ReadonlyArray"; "IExports"; "ProductTypeMode"; "HintType"; "WarningType" |]

let transformTypeVals =
    [| "*", "transferTime", "int option"
       "*", "transfers", "int option"
       "*", "delay", "int option"
       "*", "distance", "int option"
       "*", "departureDelay", "int option"
       "*", "arrivalDelay", "int option"
       "*", "transfers", "int option"
       "*", "maxTransfers", "int option"
       "*", "maxDuration", "int option"
       "*", "duration", "int option"
       "*", "results", "int option"
       "*", "bitmasks", "array<int>"
       "*", "nr", "int option"
       "*", "priority", "int option"
       "*", "realtimeDataFrom", "int option"
       "*", "categories", "array<int> option"
       "*", "realtimeDataUpdatedAt", "int option"
       "LoyaltyCard", "discount", "int option"
       "RemarksOptions", "from", "DateTime option"
       "RemarksOptions", "``to``", "DateTime option"
       "Cycle", "min", "int option"
       "Cycle", "max", "int option"
       "Frame", "t", "int option"
       "Edge", "dir", "int option"
       "IcoCrd", "x", "int"
       "IcoCrd", "y", "int"
       "RadarOptions", "frames", "int option"
       "*", "``type``", "string option" |]

let transformTypeDefns =
    [| "ScheduledDays", "IndexMap<string, bool>"
       "Products", "IndexMap<string, bool>"
       "Facilities", "IndexMap<string, string>"
       "Ids", "IndexMap<string, string>"
       "Profile",
       """
        abstract member locale : string
        abstract member timezone : string
        abstract member endpoint : string
        abstract member products : array<ProductType>
        abstract member trip : bool option
        abstract member radar : bool option
        abstract member refreshJourney : bool option
        abstract member journeysFromTrip : bool option
        abstract member reachableFrom : bool option
        abstract member journeysWalkingSpeed : bool option
        abstract member tripsByName : bool option
        abstract member remarks : bool option
        abstract member remarksGetPolyline : bool option
        abstract member lines : bool option
       """
       "HafasClient",
       """
        /// Retrieves journeys
        abstract member journeys :
            U4<string, Station, Stop, Location> ->
            U4<string, Station, Stop, Location> ->
            JourneysOptions option ->
            Promise<Journeys>
        /// refreshes a Journey
        abstract member refreshJourney : string -> RefreshJourneyOptions option -> Promise<Journey>
        /// Refetch information about a trip
        abstract member trip : string -> string -> TripOptions option -> Promise<Trip>
        /// Retrieves departures
        abstract member departures :
            U4<string, Station, Stop, Location> ->
            DeparturesArrivalsOptions option ->
            Promise<array<Alternative>>
        /// Retrieves arrivals
        abstract member arrivals :
            U4<string, Station, Stop, Location> ->
            DeparturesArrivalsOptions option ->
            Promise<array<Alternative>>
        /// Retrieves journeys from trip id to station
        abstract member journeysFromTrip :
            string ->
            StopOver ->
            U4<string, Station, Stop, Location> ->
            JourneysFromTripOptions option ->
            Promise<array<Journey>>
        /// Retrieves locations or stops
        abstract member locations : string -> LocationsOptions option -> Promise<array<U3<Station, Stop, Location>>>
        /// Retrieves information about a stop
        abstract member stop : U2<string, Stop> -> StopOptions option -> Promise<U3<Station, Stop, Location>>
        /// Retrieves nearby stops from location
        abstract member nearby : Location -> NearByOptions option -> Promise<array<U3<Station, Stop, Location>>>
        /// Retrieves stations reachable within a certain time from a location
        abstract member reachableFrom : Location -> ReachableFromOptions option -> Promise<array<Duration>>
        /// Retrieves all vehicles currently in an area.
        abstract member radar : BoundingBox -> RadarOptions option -> Promise<array<Movement>>
        /// Retrieves trips by name.
        abstract member tripsByName : string -> TripsByNameOptions option -> Promise<array<Trip>>
        /// Fetches all remarks known to the HAFAS endpoint
        abstract member remarks : RemarksOptions option -> Promise<array<Warning>>
        /// Fetches all lines known to the HAFAS endpoint
        abstract member lines : string -> LinesOptions option -> Promise<array<Line>>
        /// Fetches meta information from the HAFAS endpoint
        abstract member serverInfo : ServerOptions option -> Promise<ServerInfo>
""" |]

let transformsMemberType (typename: string) (name: string) (arr: (string * string * string) array) =
    let index =
        Array.tryFindIndex (fun (t, s, _) -> (t = "*" || t = typename) && s = name) arr

    if (index.IsSome) then
        let (_, _, transform) = arr.[index.Value]
        Some transform
    else
        None

let transformsType (name: string) (arr: (string * string) array) =
    let index =
        Array.tryFindIndex (fun (s, _) -> s = name) arr

    if (index.IsSome) then
        let (_, transform) = arr.[index.Value]
        Some transform
    else
        None

let transformsTypeVal (typename: string) (membername: string) =
    transformsMemberType typename membername transformTypeVals

let transformsTypeDefn (name: string) = transformsType name transformTypeDefns

let excludesType (name: string) =
    Array.exists (fun s -> s = name) excludeTypes

let options : Transformer.TransformerOptions =
    { prelude = Some prelude
      postlude = Some postlude
      useRecursiveTypes = true
      escapeIdent = escapeIdent
      transformType = transformType
      excludesType = excludesType
      transformsTypeVal = transformsTypeVal
      transformsTypeDefn = transformsTypeDefn }
